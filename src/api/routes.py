import loggingfrom typing import Optionalfrom fastapi import APIRouter, HTTPExceptionfrom starlette.concurrency import run_in_threadpoolfrom src.db.sqlite import get_connfrom src.services.ingest import ingest_product, get_last_price_deltalogger = logging.getLogger("price_monitor")router = APIRouter()@router.get("/health")def health() -> dict:    try:        conn = get_conn()        try:            conn.execute("SELECT 1;").fetchone()        finally:            conn.close()        return {"status": "ok"}    except Exception as e:        logger.exception("Healthcheck failed")        raise HTTPException(status_code=500, detail=str(e))def _try_get_title(product_id: int) -> Optional[str]:    try:        conn = get_conn()        try:            row = conn.execute(                "SELECT title FROM products WHERE product_id=?",                (product_id,),            ).fetchone()            return row["title"] if row else None        finally:            conn.close()    except Exception:        return None@router.get("/prices/{product_id}")def get_price(product_id: int) -> dict:    delta = get_last_price_delta(product_id)    if delta["current_price"] is None:        raise HTTPException(status_code=404, detail="Нет данных по этому товару. Сначала сделай refresh.")    return {        "product_id": product_id,        "title": _try_get_title(product_id),        **delta,    }@router.post("/prices/{product_id}/refresh")async def refresh_price(product_id: int) -> dict:    info = await run_in_threadpool(ingest_product, product_id)    delta = await run_in_threadpool(get_last_price_delta, product_id)    return {        "product": info,        "delta": delta,    }